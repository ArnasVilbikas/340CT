# Advanced Version Control

Each week you will be expected to complete a series of lab activities. You will be required to reflect on these in your assignment so make sure you keep records of what you have done.

You should refer to [this week's presentation](https://drive.google.com/open?id=1JmtlJWZy5Y5pFhDoggkLzaCSrbSa3plBh105nZtU2qA).

In this worksheet you will be learning about some of the more powerful features of the Git version control system as well as the additional functionality offered by Git remote hosting sites such as **GitHub** and **GitLab**.

## 1 Ignoring Files

There are certain files and types of files that should not be included in a repository:

1. Binary files
2. Third-party modules and libraries
3. Editor setting files
4. Local settings

Git can be configured to ignore these through a file called `.gitignore` which should be added to the root folder in the repository (the one that contains the `.git/` directory). Here is an example of the contents of this file:

```
*.exe
node_modules/
.DS_Store
```

Take a look at the repository you have been using and create a `.gitignore` file to handle the files you want excluding.

But what happens if you have already committed a file that should be ignored? Git has a way to untrack files.

```shell
$ git rm -r --cached filename
```

You will need to run this command for all files and directories you want to remove from the cache. The `-r` flag allows you to _recurse_ through subdirectories.

## 2 Hooks

The value generated by your team lies in the quality code they produce so you should take time to ensure this is securely stored on your remote repository (GitHub). The first step is to ensure each person in the team only has the minimum permissions needed to do their job. You have already added some security by configuring _protected branches_ in the last lab. We will now improve this.

In the **Code Quality** worksheet you created a range of automated tests to check both _functional_ and _non-functional_ requirements. Many of these, such as the _linter_ returned a `0` on success and a non-zero if the test failed. Until now we have triggered these tests manually but, using **git hooks** these can be triggered in response to specific events.

### 2.1 Pre-Commit

Let's use a **Git Hook** to run checks on our code before allowing us to commit. In this example git will reject any code that fails the linting test.

Use the terminal to create a new file in the `.git/hooks/` directory called `pre-commit`.

```shell
$ nano .git/hooks/pre-commit
```

You should now write a **shell script** to run the linter for your chosen language. You should already have a suitable script. Remember to include a [shebang](https://en.wikipedia.org/wiki/Shebang_(Unix)) line to identify the _script executable_, typically on a *nix system this will be `#!/bin/sh` if the script is a _shell script_.

Finally you need to set the script as executable.

```shell
$ chmod +x .git/hooks/pre-commit
```

Lets see if this works:

1. Introduce a linting error (warnings won't work).
2. Manually trigger the linter to check it is being picked up properly.
3. Try staging and committing, it should be rejected.
4. Fix the linting error.
5. Try staging and committing again, it should work this time.

By setting up a number of tests in git hooks you can automatically monitor the code quality _before_ it is committed. The downside is that the more tests you include, the slower the commit process.

### 2.2 Pre-Push

Rather than having a lot of tests that run at the commit stage you can also have tests that are triggered before the code is pushed (the push is rejected if they fail). The trick is to decide which tests should be `pre-commit` and which should be `pre-push`. This should be agreed by the team and the hooks set up before work starts.

Have a go at setting up a `pre-push` hook. You can choose whatever test or tests you want to include in this.

## 3 Bisecting

If there is a bug in a branch (master or feature) we need to be able to find out when it was introduced. To do this we will use the `git bisect` tool. Let's run a **git bisect session**.

1. Locate a branch that contains bad code.
2. Start the session by typing `git bisect start`.
3. The current commit is bad so type `git bisect bad`.
4. Locate an earlier commit which you know is good and note its short hash.
5. Now flag this as a good commit with `git bisect good xxxxxxx` where `xxxxxxx` is the hash.
6. Git will now flag a commit somewhere between the good and bad. Check this version out.
    1. If the bug is no longer there type `git bisect good`.
    2. If the bug is still there type `git bisect bad`.
7. This process will be repeated until the commit is found that introduced the bug.
    1. Type `git bisect reset` to move the `HEAD` to the commit before the bug was introduced.

## 4 Rebasing

Rebasing allows you to unplug the base of your feature branch and replug it further down the commit tree. This allows you to integrate changes to the master branch in your feature branch in a clean way.

Take a few moments to review the structure of your git repository. Open the commit graph in GitLab `Repository > Graph` or use the `git log` command to get a visual representation.

```shell
$ git log --pretty=format:"[%cn] %h %s (%cr)" --graph
```

You can navigate forward a screen using &lt;space&gt;, back a screen using `w` and quit using `q`.

You should identify any branches and either:

- If the feature is complete _delete the branch_.
- If the feature is not complete, do a rebase to make sure the feature branch contains the latest code from `master`. Check out the feature branch and `git rebase master`.

This should make your git history much easier to understand. By rebasing your feature branches they will become far easier to merge back in to the `master` branch once the feature is complete.

## 5 Tagging Releases

Next we will use tags to mark the code snapshots corresponding to the software releases.

- Go through the code in your master branch and note the 7 character _commit hash_ of the first working version of your code. After creating a tag it needs to be pushed to the remote:

```shell
$ git tag -a v0.1 -m 'Describe version 0.1 clearly, you can use multiple lines'
$ git push origin v0.1
```

These can be seen on GitLab under the `Repository > Tags` section which gives you the opportunity to download the code at that point.

Repeat the operation for subsequent working versions of your code (typically as you complete each user story). If the release contains the **Minimum Viable Product** (MVP) the version should increment to `v1.0`.

## 6 Extension Topics

Alternative branching strategies:

- Git Flow
- Forking Workflow

Tools to help you document your project.

- WEB PAGES
    - create code coverage report as a web page.
- MARKDOWN
- WIKI

- ISSUE TRACKER
    - GitHub PROJECT = Kanban board.
    - MILESTONES - sprints.
    - using issue numbers in branches (start with number?)
- BRANCHING STRATEGIES
- WEBHOOKS

## References

[rebase explained](https://medium.freecodecamp.org/git-rebase-and-the-golden-rule-explained-70715eccc372)


[continuous integration workflows for feature branching](https://www.atlassian.com/continuous-delivery/continuous-integration-workflows-for-feature-branching)

[git rebase](https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase)